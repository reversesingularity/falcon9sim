// Falcon 9 2D Simulation - Ultra Realistic Visual Simulation
console.log('Simulation2D script loaded');

class Falcon9Simulation2D {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // Physics constants
        this.G = 9.80665; // m/s²
        
        // Rocket specifications
        this.dryMass = 25400; // kg
        this.fuelMass = 453593; // kg (RP-1 + LOX)
        this.maxThrust = 7607000; // N
        this.isp = 311; // seconds
        
        // Simulation state
        this.time = 0;
        this.isRunning = false;
        this.simulationSpeed = 1.0;
        
        // Stage 1 (Booster) state
        this.stage1 = {
            active: true,
            position: { x: 100, y: 100 }, // Start 100m above ground
            velocity: { x: 0, y: 0 }, // m/s
            mass: this.dryMass + this.fuelMass,
            fuel: this.fuelMass,
            angle: 0, // radians (0 = vertical up)
            throttle: 0
        };
        
        // Stage 2 (for separation visual)
        this.stage2 = {
            active: false,
            position: { x: 100, y: 100 },
            velocity: { x: 0, y: 0 },
            visible: false
        };
        
        // Mission phases
        this.phases = [
            { name: 'PRE-LAUNCH', duration: 3, throttle: 0, targetAngle: 0 },
            { name: 'LAUNCH & ASCENT', duration: 60, throttle: 1.0, targetAngle: 0 },
            { name: 'GRAVITY TURN', duration: 90, throttle: 0.85, targetAngle: Math.PI / 4 },
            { name: 'STAGE SEPARATION', duration: 3, throttle: 0, targetAngle: Math.PI / 4 },
            { name: 'BOOST-BACK BURN', duration: 25, throttle: 0.7, targetAngle: 3 * Math.PI / 4 },
            { name: 'COAST PHASE', duration: 120, throttle: 0, targetAngle: Math.PI },
            { name: 'RE-ENTRY BURN', duration: 15, throttle: 0.5, targetAngle: Math.PI },
            { name: 'AERODYNAMIC DESCENT', duration: 40, throttle: 0, targetAngle: Math.PI },
            { name: 'LANDING BURN', duration: 20, throttle: 0.85, targetAngle: Math.PI },
            { name: 'TOUCHDOWN', duration: 0, throttle: 0, targetAngle: Math.PI }
        ];
        
        this.currentPhase = 0;
        this.phaseStartTime = 0;
        
        // Visual effects
        this.exhaustParticles = [];
        this.trajectory = [];
        this.stars = this.generateStars(200);
        this.clouds = this.generateClouds(15);
        
        // Camera
        this.camera = {
            x: 0,
            y: 0,
            zoom: 1.0,
            targetZoom: 1.0
        };
        
        // Events
        this.events = [];
        
        // Telemetry update counter
        this.telemetryFrameCount = 0;
    }
    
    resizeCanvas() {
        this.canvas.width = this.canvas.offsetWidth;
        this.canvas.height = this.canvas.offsetHeight;
    }
    
    generateStars(count) {
        const stars = [];
        for (let i = 0; i < count; i++) {
            stars.push({
                x: Math.random() * 10000 - 5000,
                y: Math.random() * 100000 + 50000,
                size: Math.random() * 2 + 0.5,
                brightness: Math.random() * 0.5 + 0.5
            });
        }
        return stars;
    }
    
    generateClouds(count) {
        const clouds = [];
        for (let i = 0; i < count; i++) {
            clouds.push({
                x: Math.random() * 5000 - 2500,
                y: Math.random() * 15000 + 5000,
                width: Math.random() * 800 + 400,
                height: Math.random() * 200 + 100,
                opacity: Math.random() * 0.3 + 0.1
            });
        }
        return clouds;
    }
    
    start() {
        this.isRunning = true;
        console.log('Simulation started');
        this.addEvent('Launch sequence initiated');
    }
    
    pause() {
        this.isRunning = false;
    }
    
    reset() {
        this.time = 0;
        this.currentPhase = 0;
        this.phaseStartTime = 0;
        this.stage1 = {
            active: true,
            position: { x: 100, y: 100 }, // Start 100m above ground
            velocity: { x: 0, y: 0 },
            mass: this.dryMass + this.fuelMass,
            fuel: this.fuelMass,
            angle: 0,
            throttle: 0
        };
        this.stage2 = {
            active: false,
            position: { x: 100, y: 100 },
            velocity: { x: 0, y: 0 },
            visible: false
        };
        this.exhaustParticles = [];
        this.trajectory = [];
        this.events = [];
        this.isRunning = false;
        this.updateTelemetry();
    }
    
    update(deltaTime) {
        // Always render, even when paused
        this.render();
        
        if (!this.isRunning) return;
        
        // Clamp deltaTime to prevent physics explosions
        const dt = Math.min(deltaTime * this.simulationSpeed, 0.1);
        
        // Debug: Log occasionally
        if (Math.random() < 0.01) {
            console.log('Update:', { dt, time: this.time.toFixed(1), phase: this.currentPhase, y: this.stage1.position.y.toFixed(0) });
        }
        
        this.time += dt;
        
        // Update phase
        this.updatePhase();
        
        // Update physics
        if (this.stage1.active) {
            this.updateStage1Physics(dt);
        }
        
        if (this.stage2.visible) {
            this.updateStage2Physics(dt);
        }
        
        // Update camera to follow stage 1
        this.updateCamera();
        
        // Update particles
        this.updateParticles(dt);
        
        // Record trajectory
        if (this.trajectory.length === 0 || 
            Math.hypot(this.stage1.position.x - this.trajectory[this.trajectory.length - 1].x,
                      this.stage1.position.y - this.trajectory[this.trajectory.length - 1].y) > 500) {
            this.trajectory.push({ ...this.stage1.position });
            if (this.trajectory.length > 200) {
                this.trajectory.shift();
            }
        }
        
        // Update telemetry (throttled to every 3rd frame for performance)
        this.telemetryFrameCount++;
        if (this.telemetryFrameCount >= 3) {
            this.updateTelemetry();
            this.telemetryFrameCount = 0;
        }
    }
    
    updatePhase() {
        const phase = this.phases[this.currentPhase];
        const phaseTime = this.time - this.phaseStartTime;
        
        if (phaseTime >= phase.duration && this.currentPhase < this.phases.length - 1) {
            this.currentPhase++;
            this.phaseStartTime = this.time;
            this.addEvent(`Phase: ${this.phases[this.currentPhase].name}`);
            
            // Handle stage separation
            if (this.currentPhase === 3) {
                this.separateStages();
            }
        }
        
        this.stage1.throttle = this.phases[this.currentPhase].throttle;
    }
    
    separateStages() {
        this.stage2.active = true;
        this.stage2.visible = true;
        this.stage2.position = { ...this.stage1.position };
        this.stage2.velocity = { 
            x: this.stage1.velocity.x, 
            y: this.stage1.velocity.y + 50 // Stage 2 continues upward
        };
        
        // Stage 1 loses mass
        this.stage1.mass = this.dryMass + this.stage1.fuel;
        
        this.addEvent('Stage separation successful');
    }
    
    updateStage1Physics(dt) {
        const phase = this.phases[this.currentPhase];
        
        // Calculate forces
        let thrust = this.maxThrust * this.stage1.throttle;
        
        // Thrust vector based on angle
        const thrustX = thrust * Math.sin(this.stage1.angle);
        const thrustY = thrust * Math.cos(this.stage1.angle);
        
        // Gravity
        const gravityY = -this.stage1.mass * this.G;
        
        // Drag (simplified)
        const altitude = this.stage1.position.y;
        const density = Math.max(0, 1.225 * Math.exp(-altitude / 8500));
        const velocity = Math.hypot(this.stage1.velocity.x, this.stage1.velocity.y);
        const dragForce = 0.5 * density * velocity * velocity * 10; // Simplified drag
        const dragX = velocity > 0 ? -dragForce * (this.stage1.velocity.x / velocity) : 0;
        const dragY = velocity > 0 ? -dragForce * (this.stage1.velocity.y / velocity) : 0;
        
        // Total forces
        const totalForceX = thrustX + dragX;
        const totalForceY = thrustY + gravityY + dragY;
        
        // Acceleration
        const accelX = totalForceX / this.stage1.mass;
        const accelY = totalForceY / this.stage1.mass;
        
        // Update velocity
        this.stage1.velocity.x += accelX * dt;
        this.stage1.velocity.y += accelY * dt;
        
        // Update position
        this.stage1.position.x += this.stage1.velocity.x * dt;
        this.stage1.position.y += this.stage1.velocity.y * dt;
        
        // Keep rocket on pad during pre-launch
        if (this.currentPhase === 0) {
            this.stage1.position.y = 100;
            this.stage1.velocity = { x: 0, y: 0 };
        }
        
        // Ground collision (only check after launch phase, not during pre-launch)
        if (this.currentPhase > 1 && this.stage1.position.y <= 0 && this.stage1.velocity.y <= 0) {
            this.stage1.position.y = 0;
            
            if (this.stage1.velocity.y < -5) {
                // Hard landing
                this.stage1.velocity = { x: 0, y: 0 };
                this.addEvent('Hard landing!');
                this.isRunning = false;
            } else if (Math.abs(this.stage1.angle) < 0.3) {
                // Successful landing (angle near 0 = upright with legs down)
                this.stage1.velocity = { x: 0, y: 0 };
                this.stage1.throttle = 0;
                this.currentPhase = this.phases.length - 1;
                this.addEvent('✓ Successful landing!');
                this.isRunning = false;
            } else {
                this.stage1.velocity.y = 0;
            }
        }
        
        // Update angle smoothly - fix landing orientation
        let targetAngle = phase.targetAngle;
        
        // Override for landing phases to ensure nose-up landing
        if (this.currentPhase >= 8) { // Landing Burn or Touchdown
            targetAngle = 0; // 0 degrees = vertical with nose up, engines down
        }
        
        const angleDiff = targetAngle - this.stage1.angle;
        this.stage1.angle += angleDiff * 0.5 * dt;
        
        // Safety check for NaN values
        if (isNaN(this.stage1.position.x) || isNaN(this.stage1.position.y)) {
            console.error('NaN detected in position, resetting');
            this.reset();
            return;
        }
        
        // Fuel consumption
        if (this.stage1.throttle > 0 && this.stage1.fuel > 0) {
            const fuelRate = (this.maxThrust / (this.isp * this.G)) * this.stage1.throttle;
            this.stage1.fuel -= fuelRate * dt;
            this.stage1.fuel = Math.max(0, this.stage1.fuel);
            this.stage1.mass = this.dryMass + this.stage1.fuel;
        }
        
        // Generate exhaust particles
        if (this.stage1.throttle > 0.1) {
            this.generateExhaust();
        }
    }
    
    updateStage2Physics(dt) {
        // Stage 2 continues upward
        this.stage2.velocity.y -= this.G * dt; // Gravity
        this.stage2.position.x += this.stage2.velocity.x * dt;
        this.stage2.position.y += this.stage2.velocity.y * dt;
    }
    
    generateExhaust() {
        const exhaustCount = Math.floor(this.stage1.throttle * 2); // Reduced from 3 to 2
        
        for (let i = 0; i < exhaustCount; i++) {
            // Calculate exhaust position at bottom of rocket
            const rocketBottom = {
                x: this.stage1.position.x - Math.sin(this.stage1.angle) * 20,
                y: this.stage1.position.y - Math.cos(this.stage1.angle) * 20
            };
            
            this.exhaustParticles.push({
                x: rocketBottom.x + (Math.random() - 0.5) * 3,
                y: rocketBottom.y + (Math.random() - 0.5) * 3,
                vx: -Math.sin(this.stage1.angle) * 50 + (Math.random() - 0.5) * 20,
                vy: -Math.cos(this.stage1.angle) * 50 + (Math.random() - 0.5) * 20,
                life: 1.0,
                size: Math.random() * 3 + 2, // Reduced from 4+3 to 3+2
                color: Math.random() < 0.5 ? '#ff6600' : '#ffaa00'
            });
        }
    }
    
    updateParticles(dt) {
        for (let i = this.exhaustParticles.length - 1; i >= 0; i--) {
            const p = this.exhaustParticles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy -= this.G * dt * 0.5; // Gravity on particles
            p.life -= dt * 3; // Faster fade (changed from 2 to 3)
            p.size *= 1.05;
            
            if (p.life <= 0) {
                this.exhaustParticles.splice(i, 1);
            }
        }
    }
    
    updateCamera() {
        // Follow stage 1
        this.camera.x = this.stage1.position.x;
        this.camera.y = this.stage1.position.y;
        
        // Auto-zoom based on altitude
        const altitude = this.stage1.position.y;
        if (altitude < 5000) {
            this.camera.targetZoom = 1.0;
        } else if (altitude < 50000) {
            this.camera.targetZoom = 0.5;
        } else {
            this.camera.targetZoom = 0.2;
        }
        
        this.camera.zoom += (this.camera.targetZoom - this.camera.zoom) * 0.02;
    }
    
    worldToScreen(worldX, worldY) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height * 0.7;
        
        const relX = (worldX - this.camera.x) * this.camera.zoom;
        const relY = -(worldY - this.camera.y) * this.camera.zoom; // Flip Y for screen coords
        
        return {
            x: centerX + relX,
            y: centerY + relY
        };
    }
    
    render() {
        try {
            // Clear canvas
            this.ctx.fillStyle = 'transparent';
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Draw background gradient
            this.drawBackground();
            
            // Draw stars
            this.drawStars();
            
            // Draw clouds
            this.drawClouds();
            
            // Draw trajectory
            this.drawTrajectory();
            
            // Draw ground
            this.drawGround();
            
            // Draw launch pad
            this.drawLaunchPad();
            
            // Draw exhaust particles
            this.drawExhaust();
            
            // Draw stage 2 if visible
            if (this.stage2.visible) {
                this.drawStage2();
            }
            
            // Draw stage 1 (main booster)
            this.drawStage1();
            
            // Debug: Draw FPS counter
            this.ctx.fillStyle = 'lime';
            this.ctx.font = '20px monospace';
            this.ctx.fillText(`FPS: ${Math.round(1/Math.max(0.001, lastTime ? (performance.now() - lastTime)/1000 : 0.016))}`, 10, 30);
            this.ctx.fillText(`Time: ${this.time.toFixed(1)}s`, 10, 55);
            this.ctx.fillText(`Y: ${this.stage1.position.y.toFixed(0)}m`, 10, 80);
            this.ctx.fillText(`Phase: ${this.currentPhase}`, 10, 105);
        } catch (error) {
            console.error('Render error:', error);
            this.isRunning = false;
        }
    }
    
    drawBackground() {
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        
        const altitude = this.stage1.position.y;
        if (altitude < 10000) {
            // Low altitude - blue sky
            gradient.addColorStop(0, '#000814');
            gradient.addColorStop(0.3, '#001d3d');
            gradient.addColorStop(0.7, '#003566');
            gradient.addColorStop(1, '#87ceeb');
        } else if (altitude < 50000) {
            // Medium altitude - darker
            gradient.addColorStop(0, '#000814');
            gradient.addColorStop(0.5, '#001d3d');
            gradient.addColorStop(1, '#003566');
        } else {
            // High altitude - space
            gradient.addColorStop(0, '#000000');
            gradient.addColorStop(0.5, '#000814');
            gradient.addColorStop(1, '#001d3d');
        }
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    drawStars() {
        const altitude = this.stage1.position.y;
        const visibility = Math.min(1, altitude / 20000);
        
        this.stars.forEach(star => {
            const screen = this.worldToScreen(star.x, star.y);
            if (screen.y < 0 || screen.y > this.canvas.height) return;
            
            this.ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * visibility})`;
            this.ctx.beginPath();
            this.ctx.arc(screen.x, screen.y, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }
    
    drawClouds() {
        const altitude = this.stage1.position.y;
        if (altitude > 15000) return;
        
        this.clouds.forEach(cloud => {
            const screen = this.worldToScreen(cloud.x, cloud.y);
            const screenWidth = cloud.width * this.camera.zoom;
            const screenHeight = cloud.height * this.camera.zoom;
            
            this.ctx.fillStyle = `rgba(255, 255, 255, ${cloud.opacity})`;
            this.ctx.beginPath();
            this.ctx.ellipse(screen.x, screen.y, screenWidth / 2, screenHeight / 2, 0, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }
    
    drawGround() {
        const groundY = this.worldToScreen(0, 0).y;
        
        // Ground
        this.ctx.fillStyle = '#2d5016';
        this.ctx.fillRect(0, groundY, this.canvas.width, this.canvas.height - groundY);
        
        // Horizon line
        this.ctx.strokeStyle = '#3a6622';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(0, groundY);
        this.ctx.lineTo(this.canvas.width, groundY);
        this.ctx.stroke();
    }
    
    drawLaunchPad() {
        const padPos = this.worldToScreen(100, 0);
        const size = 40 * this.camera.zoom;
        
        // Pad platform
        this.ctx.fillStyle = '#666';
        this.ctx.fillRect(padPos.x - size, padPos.y, size * 2, size * 0.3);
        
        // Support structures
        this.ctx.fillStyle = '#cc3333';
        const towerHeight = 60 * this.camera.zoom;
        const towerWidth = 6 * this.camera.zoom;
        
        // Four towers
        [-size * 0.8, -size * 0.4, size * 0.4, size * 0.8].forEach(offset => {
            this.ctx.fillRect(
                padPos.x + offset - towerWidth / 2,
                padPos.y - towerHeight,
                towerWidth,
                towerHeight
            );
        });
    }
    
    drawStage1() {
        const pos = this.worldToScreen(this.stage1.position.x, this.stage1.position.y);
        
        this.ctx.save();
        this.ctx.translate(pos.x, pos.y);
        this.ctx.rotate(-this.stage1.angle); // Negative because screen Y is flipped
        
        const scale = this.camera.zoom;
        const width = 35 * scale; // Increased from 7 to 35 (5x bigger)
        const height = 200 * scale; // Increased from 40 to 200 (5x bigger)
        
        // Main body - white/light gray
        this.ctx.fillStyle = '#f5f5f5';
        this.ctx.strokeStyle = '#d0d0d0';
        this.ctx.lineWidth = 1;
        this.ctx.fillRect(-width / 2, -height / 2, width, height);
        this.ctx.strokeRect(-width / 2, -height / 2, width, height);
        
        // Black interstage band
        this.ctx.fillStyle = '#0a0a0a';
        const bandY = height * 0.1 - height / 2;
        const bandHeight = height * 0.08;
        this.ctx.fillRect(-width / 2, bandY, width, bandHeight);
        
        // SpaceX logo area (white text on body)
        this.ctx.fillStyle = '#000';
        this.ctx.font = `bold ${Math.max(8, 12 * scale)}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.fillText('FALCON 9', 0, height * 0.25 - height / 2);
        
        // USA flag area (simplified)
        this.ctx.fillStyle = '#002868';
        this.ctx.fillRect(-width / 2 + 3 * scale, -height * 0.35, width * 0.15, height * 0.08);
        
        // Nose cone - pointed tip
        this.ctx.fillStyle = '#f5f5f5';
        this.ctx.strokeStyle = '#d0d0d0';
        this.ctx.beginPath();
        this.ctx.moveTo(-width / 2, -height / 2);
        this.ctx.lineTo(0, -height / 2 - 20 * scale);
        this.ctx.lineTo(width / 2, -height / 2);
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
        
        // Landing legs (4 legs) - deployed when near landing
        const nearGround = this.stage1.position.y < 5000;
        const legAngle = nearGround ? Math.PI / 4 : Math.PI / 8;
        const legLength = 30 * scale;
        
        this.ctx.strokeStyle = '#1a1a1a';
        this.ctx.lineWidth = 3 * scale;
        this.ctx.lineCap = 'round';
        
        // Draw all 4 legs
        [-1, 1].forEach(side => {
            // Upper leg segment
            this.ctx.beginPath();
            this.ctx.moveTo(width / 2.5 * side, height / 2 - 15 * scale);
            const midX = (width / 2 + legLength * 0.6 * Math.sin(legAngle)) * side;
            const midY = height / 2 - 5 * scale + legLength * 0.3 * Math.cos(legAngle);
            this.ctx.lineTo(midX, midY);
            this.ctx.stroke();
            
            // Lower leg segment with foot pad
            this.ctx.beginPath();
            this.ctx.moveTo(midX, midY);
            const footX = (width / 2 + legLength * Math.sin(legAngle)) * side;
            const footY = height / 2 + legLength * Math.cos(legAngle);
            this.ctx.lineTo(footX, footY);
            this.ctx.stroke();
            
            // Foot pad
            this.ctx.fillStyle = '#1a1a1a';
            this.ctx.fillRect(footX - 4 * scale * side, footY - 2 * scale, 8 * scale, 3 * scale);
        });
        
        // Grid fins at top (4 fins)
        this.ctx.fillStyle = '#888888';
        this.ctx.strokeStyle = '#666666';
        this.ctx.lineWidth = 1;
        
        [-1, 1].forEach(side => {
            // Top fins
            const finWidth = 18 * scale;
            const finHeight = 12 * scale;
            const finY = -height / 2 + 25 * scale;
            
            this.ctx.fillRect(
                width / 2 * side,
                finY - finHeight / 2,
                finWidth * side,
                finHeight
            );
            this.ctx.strokeRect(
                width / 2 * side,
                finY - finHeight / 2,
                finWidth * side,
                finHeight
            );
            
            // Draw grid pattern on fins
            this.ctx.strokeStyle = '#555555';
            this.ctx.lineWidth = 0.5;
            for (let i = 1; i < 4; i++) {
                const lineX = width / 2 * side + (finWidth / 4 * i) * side;
                this.ctx.beginPath();
                this.ctx.moveTo(lineX, finY - finHeight / 2);
                this.ctx.lineTo(lineX, finY + finHeight / 2);
                this.ctx.stroke();
            }
        });
        
        // Engine section - black with detailed octaweb
        this.ctx.fillStyle = '#0a0a0a';
        const engineSectionHeight = 15 * scale;
        this.ctx.fillRect(-width / 2, height / 2 - engineSectionHeight, width, engineSectionHeight);
        
        // Octaweb pattern
        this.ctx.strokeStyle = '#333333';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4);
            this.ctx.moveTo(0, height / 2 - engineSectionHeight / 2);
            this.ctx.lineTo(
                Math.cos(angle) * width / 2,
                height / 2 - engineSectionHeight / 2 + Math.sin(angle) * width / 2
            );
        }
        this.ctx.stroke();
        
        // Engine nozzles (9 Merlin engines - center + 8 in circle)
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.strokeStyle = '#000000';
        this.ctx.lineWidth = 1;
        
        // Center engine
        this.ctx.beginPath();
        this.ctx.arc(0, height / 2 - 5 * scale, 4 * scale, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        
        // Ring of 8 engines
        for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4);
            const engineRadius = width * 0.28;
            this.ctx.beginPath();
            this.ctx.arc(
                Math.cos(angle) * engineRadius,
                height / 2 - 5 * scale + Math.sin(angle) * engineRadius * 0.3,
                3.5 * scale,
                0,
                Math.PI * 2
            );
            this.ctx.fill();
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }
    
    drawStage2() {
        const pos = this.worldToScreen(this.stage2.position.x, this.stage2.position.y);
        
        this.ctx.save();
        this.ctx.translate(pos.x, pos.y);
        this.ctx.rotate(-this.stage2.angle);
        
        const scale = this.camera.zoom;
        const width = 30 * scale; // Increased from 6 to 30
        const height = 100 * scale; // Increased from 30 to 100
        
        // Main body - white/light gray
        this.ctx.fillStyle = '#f5f5f5';
        this.ctx.strokeStyle = '#d0d0d0';
        this.ctx.lineWidth = 1;
        this.ctx.fillRect(-width / 2, -height / 2, width, height);
        this.ctx.strokeRect(-width / 2, -height / 2, width, height);
        
        // Payload fairing - larger and more detailed
        this.ctx.fillStyle = '#e8e8e8';
        this.ctx.strokeStyle = '#d0d0d0';
        this.ctx.beginPath();
        this.ctx.moveTo(-width / 2, -height / 2);
        this.ctx.lineTo(0, -height / 2 - 30 * scale);
        this.ctx.lineTo(width / 2, -height / 2);
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
        
        // Fairing separation line
        this.ctx.strokeStyle = '#c0c0c0';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(0, -height / 2 - 30 * scale);
        this.ctx.lineTo(0, -height / 2);
        this.ctx.stroke();
        
        // Engine section
        this.ctx.fillStyle = '#0a0a0a';
        const engineHeight = 8 * scale;
        this.ctx.fillRect(-width / 2, height / 2 - engineHeight, width, engineHeight);
        
        // Single vacuum engine nozzle
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.strokeStyle = '#000000';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.arc(0, height / 2 - 3 * scale, 5 * scale, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        
        this.ctx.restore();
    }
    
    drawExhaust() {
        this.exhaustParticles.forEach(p => {
            const screen = this.worldToScreen(p.x, p.y);
            
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life * 0.3; // Reduced from 0.5 to 0.3
            this.ctx.beginPath();
            this.ctx.arc(screen.x, screen.y, p.size * this.camera.zoom, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.globalAlpha = 1;
        });
    }
    
    drawTrajectory() {
        if (this.trajectory.length < 2) return;
        
        this.ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([5, 5]);
        this.ctx.beginPath();
        
        this.trajectory.forEach((point, i) => {
            const screen = this.worldToScreen(point.x, point.y);
            if (i === 0) {
                this.ctx.moveTo(screen.x, screen.y);
            } else {
                this.ctx.lineTo(screen.x, screen.y);
            }
        });
        
        this.ctx.stroke();
        this.ctx.setLineDash([]);
    }
    
    updateTelemetry() {
        const mins = Math.floor(this.time / 60);
        const secs = Math.floor(this.time % 60);
        document.getElementById('missionTime').textContent = 
            `T+${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        
        document.getElementById('altitude').textContent = 
            (this.stage1.position.y / 1000).toFixed(2) + ' km';
        
        const velocity = Math.hypot(this.stage1.velocity.x, this.stage1.velocity.y);
        document.getElementById('velocity').textContent = 
            velocity.toFixed(0) + ' m/s';
        
        document.getElementById('verticalSpeed').textContent = 
            this.stage1.velocity.y.toFixed(0) + ' m/s';
        
        const fuelPercent = (this.stage1.fuel / this.fuelMass) * 100;
        document.getElementById('fuel').textContent = fuelPercent.toFixed(1) + '%';
        
        document.getElementById('throttle').textContent = 
            (this.stage1.throttle * 100).toFixed(0) + '%';
        
        document.getElementById('phaseName').textContent = 
            this.phases[this.currentPhase].name;
    }
    
    addEvent(message) {
        this.events.unshift(message);
        if (this.events.length > 10) {
            this.events.pop();
        }
        
        const eventsList = document.getElementById('eventsList');
        eventsList.innerHTML = this.events.map(event => 
            `<div class="event-item">${event}</div>`
        ).join('');
    }
}

// Initialize
let simulation;
let lastTime = null;

function animate(currentTime) {
    if (lastTime === null) {
        lastTime = currentTime;
    }
    
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    
    if (simulation) {
        simulation.update(deltaTime);
    }
    
    requestAnimationFrame(animate);
}

document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, initializing simulation');
    const canvas = document.getElementById('simulationCanvas');
    console.log('Canvas element:', canvas);
    simulation = new Falcon9Simulation2D(canvas);
    console.log('Simulation created');
    
    document.getElementById('playBtn').addEventListener('click', () => {
        console.log('Play button clicked');
        const btn = document.getElementById('playBtn');
        if (simulation.isRunning) {
            simulation.pause();
            btn.textContent = '▶ PLAY';
        } else {
            simulation.start();
            btn.textContent = '⏸ PAUSE';
        }
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
        simulation.reset();
        document.getElementById('playBtn').textContent = '▶ PLAY';
    });
    
    document.getElementById('speedSlider').addEventListener('input', (e) => {
        simulation.simulationSpeed = parseFloat(e.target.value);
        document.getElementById('speedValue').textContent = e.target.value + 'x';
    });
    
    requestAnimationFrame(animate);
});
